"use strict";
/*
* co-compose
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Runnable to execute an array of functions in sequence. The queue is
 * advanced only when the current function calls `next`.
 *
 * @example
 * ```js
 * const runner = new Runnable([async function fn1 (params, next) {
 * }])
 * ```
 */
class Runnable {
    constructor(list) {
        this.list = list;
        this.registeredFinalHandler = null;
        this.index = 0;
        this.params = [];
    }
    /**
     * Execute the middleware fn by passing params to it
     */
    async executor(fn, params) {
        await fn(...params);
    }
    /**
     * Invoke one middleware at a time. Middleware fns will be executed
     * recursively until `next` is invoked.
     *
     * If one method doesn't call `next`, then the chain will be finished
     * automatically.
     */
    async invoke() {
        const fn = this.list[this.index++];
        /**
         * Empty stack
         */
        if (!fn) {
            return this.registeredFinalHandler
                ? this.registeredFinalHandler.fn(...this.registeredFinalHandler.args)
                : Promise.resolve();
        }
        /**
         * Params to pass to next middleware fn
         */
        const resolvedParams = this.params.concat(this.invoke.bind(this));
        /**
         * Call custom resolve fn (if exists)
         */
        if (this.resolveFn) {
            return this.resolveFn(fn, resolvedParams);
        }
        await this.executor(fn, resolvedParams);
    }
    /**
     * Final handler to be executed, when chain ends successfully
     */
    finalHandler(fn, args) {
        this.registeredFinalHandler = { fn, args };
        return this;
    }
    /**
     * Define custom resolver, which is invoked for all the middleware.
     * If this method is defined, then default executor is not called
     * and it's the responsibility of this method to call the
     * middleware and pass params to it
     */
    resolve(fn) {
        this.resolveFn = fn;
        return this;
    }
    /**
     * Start the middleware queue and pass params to it. The `params`
     * array will be passed as spread arguments.
     */
    async run(params) {
        this.params = params;
        await this.invoke();
    }
}
exports.Runnable = Runnable;
