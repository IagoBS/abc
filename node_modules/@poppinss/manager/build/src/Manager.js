"use strict";
/*
* @poppinss/manager
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
/**
 * Manager class implements the Builder pattern to make instance of similar
 * implementations using a fluent API vs importing each class by hand.
 *
 * This module is used extensively in AdonisJs. For example: `Mail`, `Sessions`,
 * `Auth` and so on.
 */
class Manager {
    constructor(container) {
        this.container = container;
        /**
         * Mappings cache (if caching is enabled)
         */
        this.mappingsCache = new Map();
        /**
         * List of drivers added at runtime
         */
        this.extendedDrivers = {};
    }
    /**
     * Returns the value saved inside cache, this method will check for
     * `cacheDrivers` attribute before entertaining the cache
     */
    getFromCache(name) {
        return this.mappingsCache.get(name) || null;
    }
    /**
     * Saves value to the cache with the driver name. This method will check for
     * `cacheDrivers` attribute before entertaining the cache.
     */
    saveToCache(name, value) {
        if (this.$cacheMappings) {
            this.mappingsCache.set(name, value);
        }
    }
    /**
     * Make the extended driver instance and save it to cache (if enabled)
     */
    makeExtendedDriver(mappingName, driver, config) {
        const value = this.wrapDriverResponse(mappingName, this.extendedDrivers[driver](this.container, mappingName, config));
        this.saveToCache(mappingName, value);
        return value;
    }
    /**
     * Make the custom driver instance by checking for function on the
     * parent class.
     *
     * For example: `stmp` as the driver name will look for `createSmtp`
     * method on the parent class.
     */
    makeDriver(mappingName, driver, config) {
        const driverCreatorName = `create${driver.replace(/^\w|-\w/g, (g) => g.replace(/^-/, '').toUpperCase())}`;
        /**
         * Raise error when the parent class doesn't implement the function
         */
        if (typeof (this[driverCreatorName]) !== 'function') {
            throw new Error(`${mappingName} driver is not supported by ${this.constructor.name}`);
        }
        const value = this.wrapDriverResponse(mappingName, this[driverCreatorName](mappingName, config));
        this.saveToCache(mappingName, value);
        return value;
    }
    /**
     * Optional method to wrap the driver response
     */
    wrapDriverResponse(_, value) {
        return value;
    }
    use(name) {
        name = (name || this.getDefaultMappingName());
        const cached = this.getFromCache(name);
        if (cached) {
            return cached;
        }
        /**
         * Ensure that driver exists for a given mapping
         */
        const driver = this.getMappingDriver(name);
        if (!driver) {
            throw new Error(`Make sure to define driver for ${name} mapping`);
        }
        /**
         * Making the extended driver
         */
        if (this.extendedDrivers[driver]) {
            return this.makeExtendedDriver(name, driver, this.getMappingConfig(name));
        }
        /**
         * Making the predefined driver
         */
        return this.makeDriver(name, driver, this.getMappingConfig(name));
    }
    release(name) {
        this.mappingsCache.delete(name);
    }
    /**
     * Extend by adding new driver. The compositon of driver
     * is the responsibility of the callback function
     */
    extend(name, callback) {
        this.extendedDrivers[name] = callback;
    }
}
exports.Manager = Manager;
