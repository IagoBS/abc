"use strict";
/*
* @adonisjs/lucid
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedsRunner = void 0;
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
/**
 * Seeds runner exposes the API to list files from the seeds and
 * also run a collection of seeders
 */
class SeedsRunner {
    constructor(seedsDir, isInDevelopment) {
        this.seedsDir = seedsDir;
        this.isInDevelopment = isInDevelopment;
    }
    /**
     * Returns an array of files inside a given directory. Relative
     * paths are resolved from the project root
     */
    listSeeders() {
        return new Promise((resolve, reject) => {
            const files = utils_1.fsReadAll(this.seedsDir);
            try {
                resolve(files.sort().map((file) => {
                    const source = utils_1.esmRequire(path_1.join(this.seedsDir, file));
                    const ignored = source.developmentOnly && !this.isInDevelopment;
                    return {
                        absPath: path_1.join(this.seedsDir, file),
                        name: file.replace(RegExp(`${path_1.extname(file)}$`), ''),
                        source: utils_1.esmRequire(path_1.join(this.seedsDir, file)),
                        status: ignored ? 'ignored' : 'pending',
                    };
                }));
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Returns an array of files inside a given directory. Relative
     * paths are resolved from the project root
     */
    async run(seeder, client) {
        /**
         * Ignore when running in non-development environment and seeder is development
         * only
         */
        if (seeder.source.developmentOnly && !this.isInDevelopment) {
            return seeder;
        }
        try {
            const seederInstance = new seeder.source(client);
            if (typeof (seederInstance.run) !== 'function') {
                throw new Error(`Missing method "run" on "${seeder.name}" seeder`);
            }
            await seederInstance.run();
            seeder.status = 'completed';
        }
        catch (error) {
            seeder.status = 'failed';
            seeder.error = error;
        }
        return seeder;
    }
}
exports.SeedsRunner = SeedsRunner;
