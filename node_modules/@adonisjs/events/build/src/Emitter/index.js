"use strict";
/*
* @adonisjs/events
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitter = void 0;
/// <reference path="../../adonis-typings/events.ts" />
const emittery_1 = __importDefault(require("emittery"));
const IocResolver_1 = require("../IocResolver");
/**
 * Emitter class exposes the API for async event emitter built on top of
 * Emittery. It also exposes an API to pre-define the Typescript types
 * for different events.
 */
class Emitter {
    constructor(container) {
        this.transport = new emittery_1.default();
        this.iocResolver = new IocResolver_1.IocResolver(container);
    }
    on(event, handler) {
        if (typeof (handler) === 'string') {
            handler = this.iocResolver.getEventHandler(event, handler);
        }
        this.transport.on(event, handler);
        return this;
    }
    once(event, handler) {
        this.transport.once(event).then((data) => {
            if (typeof (handler) === 'string') {
                this.iocResolver.getEventHandler(event, handler)(data);
                this.iocResolver.removeEventHandler(event, handler);
            }
            else {
                handler(data);
            }
        });
        return this;
    }
    /**
     * Define catch all event handler to listen for all events.
     */
    onAny(handler) {
        if (typeof (handler) === 'string') {
            handler = this.iocResolver.getAnyHandler(handler);
        }
        this.transport.onAny(handler);
        return this;
    }
    emit(event, data) {
        return this.transport.emit(event, data);
    }
    off(event, handler) {
        if (typeof (handler) === 'string') {
            const offHandler = this.iocResolver.removeEventHandler(event, handler);
            if (offHandler) {
                this.transport.off(event, offHandler);
            }
            return;
        }
        this.transport.off(event, handler);
    }
    /**
     * Remove existing event listener for catch all handler
     */
    offAny(handler) {
        if (typeof (handler) === 'string') {
            const offHandler = this.iocResolver.removeAnyHandler(handler);
            if (offHandler) {
                this.transport.offAny(offHandler);
            }
            return;
        }
        this.transport.offAny(handler);
    }
    clearListener(event, handler) {
        this.off(event, handler);
    }
    clearListeners(event) {
        this.transport.clearListeners(event);
    }
    /**
     * Clear all listeners for all events
     */
    clearAllListeners() {
        this.transport.clearListeners();
    }
    listenerCount(event) {
        return this.transport.listenerCount(event ? event : undefined);
    }
    hasListeners(event) {
        return this.listenerCount(event) > 0;
    }
    /**
     * Define custom namespace for event listeners. It is set to `App/Listeners`
     * by default.
     */
    namespace(namespace) {
        this.iocResolver.namespace(namespace);
        return this;
    }
}
exports.Emitter = Emitter;
