"use strict";
/**
 * @adonisjs/http-server
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreCompiler = void 0;
/// <reference path="../../../adonis-typings/index.ts" />
const haye_1 = __importDefault(require("haye"));
const co_compose_1 = require("co-compose");
const utils_1 = require("@poppinss/utils");
const helpers_1 = require("../../helpers");
/**
 * Precompiler is used to pre compiler the route handler and middleware. We
 * lookup the middleware and controllers upfront in the IoC container
 * and cache the lookup to boost the runtime performance.
 *
 * Also each route gets a `finalHandler` property, which is used to invoke the
 * route middleware and the route actual handler
 */
class PreCompiler {
    constructor(container, middlewareStore) {
        this.middlewareStore = middlewareStore;
        /**
         * This function is used by reference to execute the route handler
         */
        this.finalRouteHandler = async function finalRouteHandler(ctx) {
            let data = {};
            let requestProfiler = ctx.profiler;
            /*
             * Passing a child to the route handler, so that all internal
             * actions can have their own child row
             */
            ctx.profiler = ctx.profiler.create('http:route:handler', data);
            const routeHandler = ctx.route.meta.resolvedHandler;
            let returnValue;
            try {
                if (routeHandler.type === 'function') {
                    returnValue = await routeHandler.handler(ctx);
                }
                else {
                    data.controller = routeHandler.namespace;
                    data.method = routeHandler.method;
                    returnValue = await this.resolver.call(routeHandler, ctx.route.meta.namespace, [ctx]);
                }
                if (helpers_1.useReturnValue(returnValue, ctx)) {
                    ctx.response.send(returnValue);
                }
                ctx.profiler.end();
                ctx.profiler = requestProfiler;
            }
            catch (error) {
                ctx.profiler.end();
                ctx.profiler = requestProfiler;
                throw error;
            }
        }.bind(this);
        /**
         * This function is used by reference to execute the route middleware + route handler
         */
        this.routeMiddlewareHandler = async function routeMiddlewareHandler(ctx) {
            await new co_compose_1.Middleware()
                .register(ctx.route.meta.resolvedMiddleware)
                .runner()
                .resolve(this.middlewareStore.invokeMiddleware.bind(this.middlewareStore))
                .finalHandler(this.finalRouteHandler, [ctx])
                .run([ctx]);
        }.bind(this);
        this.resolver = container.getResolver(undefined, 'httpControllers', 'App/Controllers/Http');
    }
    /**
     * Pre-compiling the handler to boost the runtime performance
     */
    compileHandler(route) {
        if (typeof (route.handler) === 'string') {
            route.meta.resolvedHandler = this.resolver.resolve(route.handler, route.meta.namespace);
        }
        else {
            route.meta.resolvedHandler = { type: 'function', handler: route.handler };
        }
    }
    /**
     * Pre-compile the route middleware to boost runtime performance
     */
    compileMiddleware(route) {
        route.meta.resolvedMiddleware = route.middleware.map((item) => {
            if (typeof (item) === 'function') {
                return { type: 'function', value: item, args: [] };
            }
            /*
             * Extract middleware name and args from the string
             */
            const [{ name, args }] = haye_1.default.fromPipe(item).toArray();
            /*
             * Get resolved node for the given name and raise exception when that
             * name is missing
             */
            const resolvedMiddleware = this.middlewareStore.getNamed(name);
            if (!resolvedMiddleware) {
                throw new utils_1.Exception(`Cannot find named middleware ${name}`, 500, 'E_MISSING_NAMED_MIDDLEWARE');
            }
            resolvedMiddleware.args = args;
            return resolvedMiddleware;
        });
    }
    /**
     * Sets `finalHandler` property on the `route.meta`. This method
     * can be invoked to execute route middleware stack + route
     * controller/closure.
     */
    setFinalHandler(route) {
        if (route.meta.resolvedMiddleware && route.meta.resolvedMiddleware.length) {
            route.meta.finalHandler = this.routeMiddlewareHandler;
        }
        else {
            route.meta.finalHandler = this.finalRouteHandler;
        }
    }
    /**
     * Pre-compile route handler and it's middleware to boost runtime performance. Since
     * most of this work is repetitive, we pre-compile and avoid doing it on every
     * request
     */
    compileRoute(route) {
        this.compileHandler(route);
        this.compileMiddleware(route);
        this.setFinalHandler(route);
    }
}
exports.PreCompiler = PreCompiler;
