"use strict";
/**
 * @adonisjs/http-server
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestHandler = void 0;
/// <reference path="../../../adonis-typings/index.ts" />
const utils_1 = require("@poppinss/utils");
const co_compose_1 = require("co-compose");
/**
 * Handles the request by invoking it's middleware chain, along with the
 * route finalHandler
 */
class RequestHandler {
    constructor(middlewareStore, router) {
        this.middlewareStore = middlewareStore;
        this.router = router;
    }
    /**
     * Executes the middleware chain, followed by the route handler.
     */
    async invokeHandler(ctx) {
        await this
            .globalMiddleware
            .runner()
            .resolve(this.middlewareStore.invokeMiddleware.bind(this.middlewareStore))
            .finalHandler(ctx.route.meta.finalHandler, [ctx])
            .run([ctx]);
    }
    /**
     * Finds the route for the request
     */
    findRoute(ctx) {
        const url = ctx.request.url();
        const method = ctx.request.method();
        const hostname = ctx.request.hostname();
        /*
         * Profiling `route.match` method
         */
        const matchRoute = ctx.profiler.profile('http:route:match');
        const route = this.router.match(url, method, hostname || undefined);
        matchRoute.end();
        /*
         * Raise error when route is missing
         */
        if (!route) {
            throw new utils_1.Exception(`Cannot ${method}:${url}`, 404, 'E_ROUTE_NOT_FOUND');
        }
        /*
         * Attach `params`, `subdomains` and `route` when route is found. This
         * information only exists on a given route
         */
        ctx.params = route.params;
        ctx.subdomains = route.subdomains;
        ctx.route = route.route;
        ctx.routeKey = route.routeKey;
    }
    /**
     * Handles the request and invokes required middleware/handlers
     */
    async handle(ctx) {
        this.findRoute(ctx);
        await this.invokeHandler(ctx);
    }
    /**
     * Computing certain methods to optimize for runtime performance
     */
    commit() {
        const middleware = this.middlewareStore.get();
        if (middleware.length) {
            this.globalMiddleware = new co_compose_1.Middleware().register(middleware);
        }
        else {
            this.invokeHandler = async (ctx) => ctx.route.meta.finalHandler(ctx);
        }
    }
}
exports.RequestHandler = RequestHandler;
