"use strict";
/*
* @adonisjs/encryption
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hmac = void 0;
const crypto_1 = require("crypto");
const utils_1 = require("@poppinss/utils");
/**
 * A generic class for generating SHA-256 Hmac for verifying the value
 * integrity.
 */
class Hmac {
    constructor(key) {
        this.key = key;
    }
    /**
     * Generate the hmac
     */
    generate(value) {
        return utils_1.base64.urlEncode(crypto_1.createHmac('sha256', this.key).update(value).digest());
    }
    /**
     * Compare raw value against an existing hmac
     */
    compare(value, existingHmac) {
        const newValueBuffer = Buffer.from(this.generate(value));
        /**
         * Allocate space as per the newHash length. This is required to avoid `safeEqual`
         * method from raising exceptions in case of length mis-match.
         *
         * Why there will be a length mis-match?
         * - The signed value was in correct format
         * - The encoded value was decoded
         * - However, the hash appended to the signed value was tampered and now has less
         *   characters than the original hash. The `safeEqual` method will raise exception
         *   if two buffers of different lengths are compared
         */
        const existingValueBuffer = Buffer.alloc(newValueBuffer.length);
        existingValueBuffer.write(existingHmac);
        return utils_1.safeEqual(newValueBuffer, existingValueBuffer);
    }
}
exports.Hmac = Hmac;
