"use strict";
/*
* @adonisjs/auth
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDatabaseProvider = void 0;
const luxon_1 = require("luxon");
const utils_1 = require("@poppinss/utils");
const ProviderToken_1 = require("../../Tokens/ProviderToken");
/**
 * Database backend tokens provider
 */
class TokenDatabaseProvider {
    constructor(config, db) {
        this.config = config;
        this.db = db;
    }
    /**
     * Returns the query client for database queries
     */
    getQueryClient() {
        return this.config.connection
            ? this.db.connection(this.config.connection)
            : this.db.connection();
    }
    /**
     * Returns the builder query for a given token + type
     */
    getLookupQuery(tokenId) {
        return this
            .getQueryClient()
            .from(this.config.table)
            .where('id', tokenId);
    }
    /**
     * Reads the token using the lookup token id
     */
    async read(tokenId, tokenHash) {
        const client = this.getQueryClient();
        /**
         * Find token using id
         */
        const tokenRow = await this.getLookupQuery(tokenId).first();
        if (!tokenRow || !tokenRow.token) {
            return null;
        }
        /**
         * Ensure hash of the user provided value is same as the one inside
         * the database
         */
        if (!utils_1.safeEqual(tokenRow.token, tokenHash)) {
            return null;
        }
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const { name, user_id, token: value, expires_at, type, ...meta } = tokenRow;
        let expiresAt;
        /**
         * Parse dialect date to an instance of Luxon
         */
        if (expires_at instanceof Date) {
            expiresAt = luxon_1.DateTime.fromJSDate(expires_at);
        }
        else if (expires_at && typeof (expires_at) === 'string') {
            expiresAt = luxon_1.DateTime.fromFormat(expires_at, client.dialect.dateTimeFormat);
        }
        else if (expires_at && typeof (expires_at) === 'number') {
            expiresAt = luxon_1.DateTime.fromMillis(expires_at);
        }
        /**
         * Ensure token isn't expired
         */
        if (expiresAt && expiresAt.diff(luxon_1.DateTime.local(), 'millisecond').milliseconds <= 0) {
            return null;
        }
        const token = new ProviderToken_1.ProviderToken(name, value, user_id, type);
        token.expiresAt = expiresAt;
        token.meta = meta;
        return token;
    }
    /**
     * Saves the token and returns the persisted token lookup id.
     */
    async write(token) {
        const client = this.getQueryClient();
        /**
         * Payload to save to the database
         */
        const payload = {
            user_id: token.userId,
            name: token.name,
            token: token.tokenHash,
            type: token.type,
            expires_at: token.expiresAt ? token.expiresAt.toFormat(client.dialect.dateTimeFormat) : null,
            created_at: luxon_1.DateTime.local().toFormat(client.dialect.dateTimeFormat),
            ...token.meta,
        };
        const [persistedToken] = await client.table(this.config.table).insert(payload).returning('id');
        return String(persistedToken);
    }
    /**
     * Removes a given token
     */
    async destroy(tokenId) {
        await this.getLookupQuery(tokenId).delete();
    }
}
exports.TokenDatabaseProvider = TokenDatabaseProvider;
